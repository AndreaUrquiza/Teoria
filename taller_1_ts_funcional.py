# -*- coding: utf-8 -*-
"""TALLER 1 TS funcional.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Goa2xoTXvU0O0ApmYkK-gH_0Fltyqt0

# Teoría de señales - Taller 1



_Transformada de Fourier, Sistemas lineales y Modulación_

----

Hallar la ecuación diferencial que describe cada uno de los siguientes circuitos:

<center><img src='taller1.svg' style='width: 70%'></img></center>

  1. Hallar la función de transferencia $h(t)$.
  1. Asumir que a la entrada $x(t)$ hay un **pulso cuadrado**, hallar la salida en tiempo ($y(t)$) y frecuencia ($Y(\omega)$).
  1. Modular la salida del sistema en cada una de las modulaciones vistas en clase (representar la señal modulada en el tiempo y hallar su espectro)

# Función de transferencia

**1. Hallar la función de transferencia**

Para hallar la función de transferencia se hace una conversión de los elementos del circuito al dominio de la frecuencia y acto seguido se hace el equivalente de las impedancias para relacionar la tensión de entrada con la de salida.


![Circuito6.png](data:image/png;base64,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)

$$
C_1 ----> \frac{1}{S*C_1}  [Ω]
$$ 
$$
R1, R2 -----> R1, R2  [Ω]
$$

se soluciona el paralelo entre el capacitor y R_1


$$ R_1 || \frac{1}{SC_1}  =  \frac{R_1*\frac{1}{SC_1}}{R_1+\frac{1}{SC_1}} = \frac{R_1}{R_1*S*C_1+1}  $$

$$  \frac{R_1}{S*R_1*C_1+1}*X(S) = (\frac{R_1}{S*R_1*C_1+1}+R_2)*Y(S)  $$


$$  \frac{Y(S)}{X(S)} = \frac{\frac{R_1}{R_1SC_1+1}}{\frac{R_1}{S*R_1*C_1+1}+R_2}  $$

$$G(s)=\frac{1}{R_2 SC+\frac{R_2}{R_1}+1} =\frac{\frac{1}{R_2 C}}{S+\frac{R_2}{R_1 R_2 C}+\frac{1}{R_2}} = \frac{1}{R_2 C} \frac{1}{S+\frac{R_1 + R_2}{C R_1 R_2}}$$
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
from matplotlib import pyplot as plt
from scipy.signal import lti
from scipy.fftpack import fft, fftfreq, fftshift

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import sympy as sym
sym.init_printing()

s = sym.symbols('s', complex=True)
t, R1, R2, C = sym.symbols('t R1 R2 C', positive=True)
X = sym.Function('X')(s)

Y = (1/(R2*C))/(s + ((R2+R1)/(R1*R2*C))) * X

y = sym.inverse_laplace_transform(Y.subs(X, 1), s, t)
Y,y

R1 = 1
R2 = 2
C = 0.4
A = 1/(R2*C)
num = [A] 
den = [1,((R2+R1)/(R1*R2*C)) ] 

G = lti(num, den)   
tv, h = G.impulse(N=5000)  #se genera la respuesta impulso del sistema 

plt.plot(tv, h, label='$h(t)$') #se gráfica la respuesta impulso

plt.grid(True)
plt.legend()
plt.title("Impulse response")
plt.xlabel("Time [$s$]")
plt.ylabel("Amplitude")
plt.show()

"""# 2. Si Input signal es $x(t)= rect_{tau} (t)$"""

tau= 2
Fs= 500
Nm=tau*Fs
A = 1/tau

t_1 = 1
t1 = np.linspace(0,0,Nm)
t2 = np.linspace(0,A,Nm)
t3 = np.linspace(A,2*A,Nm)

t = np.append(t1,(t2,t3))

x1 = 0*t1
x2 = A*np.ones(len(t2))
x3 = 0*t3

xt = np.append(x1,(x2,x3))

plt.figure(figsize=(18, 4))
plt.subplot(131)
plt.plot(t,xt,'orange',linewidth=2)
plt.title(r'Pulso cuadradO')
plt.xlabel("t [s]",fontsize = 14)
plt.ylabel("x(t)",fontsize = 14)
plt.grid()

"""- Se determina X(w) por fft a aprtir de $x(t)$"""

vf = np.fft.fftfreq(len(xt),1/Fs) 
Xw = np.fft.fft(xt) 
xe = np.fft.ifft(Xw)

plt.figure(figsize=(18, 4))
plt.subplot(121)
plt.stem(vf,abs(Xw),'r',use_line_collection= True)
plt.title(r'|X[n]|')
plt.xlabel(r'$f$[Hz]',fontsize = 14)
plt.ylabel(r'$|X[n]|$',fontsize = 14)
plt.axis('tight')
plt.grid()
plt.subplot(122)
plt.plot(t,xe,'orange',label = '${x}[k]$')
plt.title(r'Reconstrucción completa')
plt.xlabel(r't',fontsize = 14)
plt.ylabel(r'$x[n]$',fontsize = 14)
plt.grid()

"""- Se determina $X(w)$ escribiendo la transformada de Lpalcade del pulso cuadrado con ancho 0.5 y graficandola"""

X_in = (A/s)*(1-sym.exp(-A*s))
X_in

"""- Se halla la respuesta del sistema ante el pulso cuadrado"""

#Comparar la salida de convolve con la output, debe ser la misma.
plt.figure(figsize=(16, 4), dpi=90)

_,output,_ = G.output(xt, t)
output_c = np.convolve(xt, h)[:t.shape[0]]*((t[-1]/t.shape[0]))

plt.plot(t,xt, '-', C='C0', label='Input')
plt.plot(t, output, '-', C='C1', linewidth=7, alpha=0.3, label='Output (sim)')
plt.plot(t, output_c, '--', C='C2', label='Output (convolve)')

plt.grid(True)
plt.legend()
# plt.xlim(0, 20)
plt.xlabel('Time [$s$]')
plt.ylabel('Amplitude')
plt.show()

import sympy as sym
from sympy.abc import s,t,x,y,z
import numpy as np 
from sympy.integrals import inverse_laplace_transform,laplace_transform
import matplotlib.pyplot as plt
from ipywidgets import interact, interactive, fixed, interact_manual

U2 = 0.5/s*sym.exp(0.5*s*0)
U3 = -0.5/s*sym.exp(-0.5*s)

#X_in = (0.5/s)*(1-sym.exp(-0.5*s))
#x_in = sym.inverse_laplace_transform(X_in, s, t)
#sym.plot(x_in, (t, 0, 1), xlabel='$t$', ylabel='$x_{in}(t)$')

R1 = 1
R2 = 2
C = 0.4
A = 1/(R2*C)
G = (1/(R2*C))/(s + ((R2+R1)/(R1*R2*C))) 

Y2 = G * U2
Y3 = G * U3


u2 = inverse_laplace_transform(U2,s,t)
u3 = inverse_laplace_transform(U3,s,t)
y2 = inverse_laplace_transform(Y2,s,t)
y3 = inverse_laplace_transform(Y3,s,t)

tm = np.linspace(-0.000000001,0.7,1000)
us = np.zeros(len(tm))
ys = np.zeros(len(tm))

for u in [u2,u3]:
  for i in range(len(tm)):
      us[i] += u.subs(t,tm[i])
      
for y in [y2,y3]:
  for i in range(len(tm)):
      ys[i] += y.subs(t,tm[i])

plt.figure()
plt.plot(tm,us,label='u(t)')
plt.plot(tm,ys,label='y(t)')
plt.legend()
plt.grid (True)
plt.xlabel('time')
plt.show()